<!DOCTYPE html>
<html>
<head>
    <title>宇宙成因核素分析工具</title>
    <style>
        /* 样式部分保持不变 */
    </style>
</head>
<body>
    <!-- HTML结构保持不变 -->
    <script>
// 核素物理常数
const NUCLIDE_DATA = {
    '¹⁰Be': { P0: 6.0, lambda: 4.99e-7 },
    '²⁶Al': { P0: 36.8, lambda: 9.83e-7 },
    '¹⁴C': { P0: 20, lambda: 1.209e-4 },
    '³He': { P0: 124, lambda: 0 },
    '²¹Ne': { P0: 21, lambda: 0 },
    '³⁶Cl': { P0: 54, lambda: 2.303e-6 }
};

// 输入验证函数
function validateInput(id, min=null, max=null) {
    const input = document.getElementById(id);
    const value = parseFloat(input.value);
    
    if (isNaN(value)) {
        input.style.border = "2px solid red";
        return null;
    }
    
    if (min !== null && value < min) return null;
    if (max !== null && value > max) return null;
    
    input.style.border = "1px solid #ccc";
    return value;
}

// 大气压力计算 (返回g/cm²)
function atmosphericPressure(elevation) {
    // 标准海平面大气压 (g/cm²)
    const P0 = 1033.227;
    // 使用简化大气模型
    return P0 * Math.exp(-elevation/8400);
}

// 海拔校正因子 (基于Lal/Stone模型)
function elevationScaling(elevation, latitude) {
    const h = atmosphericPressure(elevation);
    const Rc = 14.9 * Math.pow(Math.cos(Math.abs(latitude)*Math.PI/180), 4);
    
    // 高海拔校正因子
    const highAltTerm = Math.exp((1033-h)/150);
    
    // 纬度相关项
    const latTerm = 1 + 0.0008 * (1033-h) * Math.exp(-Rc/10);
    
    return highAltTerm * latTerm;
}

// 纬度校正因子
function latitudeScaling(latitude) {
    const Rc = 14.9 * Math.pow(Math.cos(Math.abs(latitude)*Math.PI/180), 4);
    return 1 - Math.exp(-10.275 * Math.pow(Rc, -0.9615));
}

// 深度衰减校正
function depthAttenuation(depth, density) {
    return Math.exp(-(depth * density)/150);
}

// 暴露年龄计算
function calculateExposureAge(N, P, lambda) {
    if (P <= 0) return null;
    if (lambda === 0) return N / P;
    
    try {
        const age = -Math.log(1 - (N * lambda)/P) / lambda;
        return isFinite(age) ? age : null;
    } catch {
        return null;
    }
}

// 侵蚀速率计算
function calculateErosionRate(be10Data, al26Data) {
    const L = 150;
    const ratio = (be10Data.N * al26Data.P) / (al26Data.N * be10Data.P);
    const epsilon = (al26Data.lambda - ratio * be10Data.lambda) / ((ratio - 1)/L);
    return isFinite(epsilon) ? epsilon : null;
}

function calculateAll() {
    // 清除旧结果
    document.getElementById('error').style.display = 'none';
    document.getElementById('results').style.display = 'none';

    // 获取并验证输入
    const inputs = {
        lat: validateInput('latitude', -90, 90),
        elev: validateInput('elevation', 0),
        depth: validateInput('depth', 0),
        density: validateInput('density', 0.1, 5.0) || 2.7,
        be10: validateInput('be10', 0),
        al26: validateInput('al26', 0)
    };

    // 检查必要参数
    if (Object.values(inputs).slice(0,4).some(v => v === null)) {
        showError("请正确填写所有基本参数（纬度、海拔、深度、密度）");
        return;
    }

    // 计算校正因子
    const scalingFactors = {
        elevation: elevationScaling(inputs.elev, inputs.lat),
        latitude: latitudeScaling(inputs.lat),
        depth: depthAttenuation(inputs.depth, inputs.density)
    };

    // 计算各核素产率
    const productionRates = {};
    Object.entries(NUCLIDE_DATA).forEach(([name, data]) => {
        productionRates[name] = data.P0 * scalingFactors.elevation 
                              * scalingFactors.latitude * scalingFactors.depth;
    });

    // 显示计算结果
    showResults(inputs, scalingFactors, productionRates);
}

// 其他辅助函数保持不变...
</script>
</body>
</html>
